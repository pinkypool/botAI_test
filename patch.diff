 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/rag_bot.py b/rag_bot.py
index 0eefa48657c5e0d28b273e2625e5ea5dbb1af8e2..a3e18dcd0dd4271c7be9ffe8fe10eea4e3efe613 100644
--- a/rag_bot.py
+++ b/rag_bot.py
@@ -89,54 +89,58 @@ prompt_template = PromptTemplate(
 )
 db = Chroma(
     persist_directory="rag_knowledge_base/chroma_db",
     embedding_function=HuggingFaceEmbeddings(model_name="intfloat/multilingual-e5-small")
 )
 llm = Ollama(model="yandex/YandexGPT-5-Lite-8B-instruct-GGUF")
 memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
 qa = ConversationalRetrievalChain.from_llm(
     llm=llm,
     retriever=db.as_retriever(),
     memory=memory,
     combine_docs_chain_kwargs={"prompt": prompt_template}
 )
 
 # --- –ì–µ–æ–∫–æ–¥–∏–Ω–≥, –ø–æ–∏—Å–∫ –¥–æ—Å—Ç–∞–≤–∫–∏, –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ ---
 def geocode_address_2gis(address, api_key=DGIS_API_KEY):
     url = "https://catalog.api.2gis.com/3.0/items/geocode"
     params = {"q": address, "key": api_key, "fields": "items.point"}
     resp = requests.get(url, params=params)
     data = resp.json()
     if data.get("result", {}).get("items"):
         point = data["result"]["items"][0]["point"]
         return float(point["lat"]), float(point["lon"])
     return None
 
-def find_nearest_pickup(user_coords, pickup_points):
+def find_nearest_pickup(user_coords, pickup_points, available_names=None):
     best_point = None
     min_dist = float("inf")
     for point in pickup_points:
+        if available_names:
+            match = any(name.lower() in point["name"].lower() for name in available_names)
+            if not match:
+                continue
         # –ê–≤—Ç–æ-–≥–µ–æ–∫–æ–¥–∏–º –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
         if not point.get("lat") or not point.get("lon"):
             coords = geocode_address_2gis(point["address"])
             if coords:
                 point["lat"], point["lon"] = coords
             else:
                 continue
         pickup_coords = (point["lat"], point["lon"])
         dist = geodesic(user_coords, pickup_coords).kilometers
         if dist < min_dist:
             min_dist = dist
             best_point = point
     return best_point, min_dist
 
 def get_delivery_price(user_text: str, order_sum: int = 0) -> str:
     user_text = user_text.lower()
     for zone, price in delivery_zones.items():
         if zone in user_text:
             if order_sum >= FREE_DELIVERY_SUM:
                 return "–î–æ—Å—Ç–∞–≤–∫–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –ø—Ä–∏ –∑–∞–∫–∞–∑–µ –æ—Ç 10 000 ‚Ç∏."
             return f"–°—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–æ —Ä–∞–π–æ–Ω—É '{zone.title()}': {price} ‚Ç∏."
     for city, price in city_delivery.items():
         if city in user_text:
             if order_sum >= FREE_DELIVERY_SUM:
                 return f"–î–æ—Å—Ç–∞–≤–∫–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –ø–æ –≥–æ—Ä–æ–¥—É –ø—Ä–∏ –∑–∞–∫–∞–∑–µ –æ—Ç 10 000 ‚Ç∏."
diff --git a/rag_bot.py b/rag_bot.py
index 0eefa48657c5e0d28b273e2625e5ea5dbb1af8e2..a3e18dcd0dd4271c7be9ffe8fe10eea4e3efe613 100644
--- a/rag_bot.py
+++ b/rag_bot.py
@@ -144,245 +148,258 @@ def get_delivery_price(user_text: str, order_sum: int = 0) -> str:
     return "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–∞–π–æ–Ω –∏–ª–∏ –≥–æ—Ä–æ–¥. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É—Ç–æ—á–Ω–∏—Ç–µ –∞–¥—Ä–µ—Å –∏–ª–∏ —Ä–∞–π–æ–Ω –¥–æ—Å—Ç–∞–≤–∫–∏!"
 
 # --- –í—Å—è —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞ –æ—Å—Ç–∞–ª–∞—Å—å –ø—Ä–µ–∂–Ω–µ–π: —Ç–æ–≤–∞—Ä—ã, –ø–∞–º—è—Ç—å, –Ω–∞–ª–∏—á–∏–µ ---
 def detect_stock_question(query: str) -> bool:
     stock_patterns = [
         r'(–µ—Å—Ç—å|–∏–º–µ–µ—Ç—Å—è|–¥–æ—Å—Ç—É–ø–Ω)[–∞-—è]*\s*(–ª–∏\s*)?(–≤\s*–Ω–∞–ª–∏—á–∏–∏|–Ω–∞\s*—Å–∫–ª–∞–¥[–∞-—è]*)',
         r'(–≥–¥–µ\s*–≤–∑—è—Ç—å|–≥–¥–µ\s*–∫—É–ø–∏—Ç—å|–≥–¥–µ\s*–Ω–∞–π—Ç–∏|–Ω–∞\s*–∫–∞–∫–æ–π\s*—Ç–æ—á–∫–µ|–Ω–∞\s*—Ç–æ—á–∫–µ)',
         r'(—Å–∫–æ–ª—å–∫–æ\s*–æ—Å—Ç–∞–ª–æ—Å—å|–∫–∞–∫–æ–µ\s*–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ)',
         r'(–º–æ–∂–Ω–æ\s*–∑–∞–±—Ä–∞—Ç—å|–º–æ–∂–Ω–æ\s*–∫—É–ø–∏—Ç—å|—Å–∞–º–æ–≤—ã–≤–æ–∑|–∑–∞–±—Ä–∞—Ç—å)',
         r'(–≥–¥–µ\s*–∑–∞–±—Ä–∞—Ç—å|–¥–æ—Å—Ç–∞–≤–∫–∞)'
     ]
     query = re.sub(r'[^\w\s]', '', query.lower())
     return any(re.search(pattern, query) for pattern in stock_patterns)
 
 def find_similar_products(query: str, product_list: list, n=3, cutoff=0.6) -> list:
     query = re.sub(r'[^\w\s]', '', query.lower())
     return get_close_matches(query, product_list, n=n, cutoff=cutoff)
 
 def extract_product_name(query: str) -> str:
     stop_words = {'–µ—Å—Ç—å', '–ª–∏', '–≥–¥–µ', '–≤–∑—è—Ç—å', '–∫—É–ø–∏—Ç—å', '–Ω–∞–π—Ç–∏',
                 '—Å–∫–æ–ª—å–∫–æ', '–æ—Å—Ç–∞–ª–æ—Å—å', '–Ω–∞–ª–∏—á–∏–µ', '–Ω–∞', '—Ç–æ—á–∫–µ',
                 '–º–æ–∂–Ω–æ', '–∑–∞–±—Ä–∞—Ç—å', '–∫–∞–∫–æ–µ', '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', '–≤', '—Å–∞–º–æ–≤—ã–≤–æ–∑', '–¥–æ—Å—Ç–∞–≤–∫–∞'}
     words = [word for word in re.findall(r'\w+', query.lower()) if word not in stop_words]
     return ' '.join(words)
 
-def get_product_stock(meta_href: str, api_key: str) -> str:
+def get_product_stock(meta_href: str, api_key: str):
     url = f"https://api.moysklad.ru/api/remap/1.2/report/stock/bystore?filter=product={meta_href}"
     headers = {"Authorization": f"Bearer {api_key}", "Accept-Encoding": "gzip", "Content-Type": "application/json"}
     try:
         response = requests.get(url, headers=headers)
         response.raise_for_status()
         data = response.json()
         rows = data.get("rows", [])
         stocks = []
+        stock_dict = {}
         for item in rows:
             for store in item.get("stockByStore", []):
                 if store.get("stock", 0) > 0:
                     store_name = store.get("name", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–∫–ª–∞–¥")
-                    stocks.append(f"‚Ä¢ {store_name}: {int(store['stock'])} —à—Ç.")
+                    qty = int(store["stock"])
+                    stock_dict[store_name] = qty
+                    stocks.append(f"‚Ä¢ {store_name}: {qty} —à—Ç.")
         if stocks:
-            return "üîç **–ù–∞–ª–∏—á–∏–µ —Ç–æ–≤–∞—Ä–∞:**\n" + "\n".join(stocks)
-        return "–¢–æ–≤–∞—Ä–∞ –Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏."
+            return "üîç **–ù–∞–ª–∏—á–∏–µ —Ç–æ–≤–∞—Ä–∞:**\n" + "\n".join(stocks), stock_dict
+        return "–¢–æ–≤–∞—Ä–∞ –Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏.", {}
     except requests.exceptions.RequestException as e:
         logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {str(e)}")
-        return f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –Ω–∞–ª–∏—á–∏—è: {str(e)}"
+        return f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –Ω–∞–ª–∏—á–∏—è: {str(e)}", {}
 
 def get_product_price(product_name: str) -> int:
     """–ò—â–µ—Ç —Ü–µ–Ω—É —Ç–æ–≤–∞—Ä–∞ –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –º–µ–Ω—é –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ—ë."""
     price_pattern = re.compile(r"–¶–µ–Ω–∞:\s*(\d+)")
     for path in glob.glob("rag_knowledge_base/menu_*.txt"):
         with open(path, encoding="utf-8") as f:
             for line in f:
                 if product_name.lower() in line.lower():
                     m = price_pattern.search(line)
                     if m:
                         return int(m.group(1))
     return 0
     
 # --- –†–∞–±–æ—Ç–∞ —Å –∑–∞–∫–∞–∑–æ–º ---
 def summarize_order() -> int:
     """–í—ã–≤–æ–¥–∏—Ç –≤—Å–µ —Ç–æ–≤–∞—Ä—ã –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—â—É—é —Å—É–º–º—É."""
     total = 0
     if not order:
         print("–ë–æ—Ç: –ó–∞–∫–∞–∑ –ø—É—Å—Ç.")
         return total
     print("–ë–æ—Ç: –í–∞—à –∑–∞–∫–∞–∑:")
     for item in order:
         subtotal = item["price"] * item["quantity"]
         total += subtotal
         print(f" - {item['name']} x{item['quantity']} = {subtotal} ‚Ç∏")
     print(f"–ò—Ç–æ–≥–æ: {total} ‚Ç∏")
     return total
 
-def respond_with_delivery_info(address: str, order_total: int) -> None:
+def respond_with_delivery_info(address: str, order_total: int, available_names=None) -> None:
     """–°–æ–æ–±—â–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏ –∏ –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É —Å–∞–º–æ–≤—ã–≤–æ–∑–∞."""
     delivery_msg = get_delivery_price(address, order_total)
     print("–ë–æ—Ç:", delivery_msg)
     coords = geocode_address_2gis(address)
     if coords:
-        nearest, dist = find_nearest_pickup(coords, pickup_points)
-        print(
-            f"–ë–æ—Ç: –ë–ª–∏–∂–∞–π—à–∞—è —Ç–æ—á–∫–∞ –¥–ª—è —Å–∞–º–æ–≤—ã–≤–æ–∑–∞ ‚Äî {nearest['name']} ({nearest['address']}). –î–æ –Ω–µ—ë {dist:.1f} –∫–º."
-        )
+        nearest, dist = find_nearest_pickup(coords, pickup_points, available_names)
+        if nearest:
+            print(
+                f"–ë–æ—Ç: –ë–ª–∏–∂–∞–π—à–∞—è —Ç–æ—á–∫–∞ –¥–ª—è —Å–∞–º–æ–≤—ã–≤–æ–∑–∞ ‚Äî {nearest['name']} ({nearest['address']}). –î–æ –Ω–µ—ë {dist:.1f} –∫–º."
+            )
+        else:
+            print("–ë–æ—Ç: –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ç–æ–≤–∞—Ä —Å–µ–π—á–∞—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è —Å–∞–º–æ–≤—ã–≤–æ–∑–∞ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏.")
     else:
         print(
             "–ë–æ—Ç: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–∞—à–µ–≥–æ –∞–¥—Ä–µ—Å–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ."
         )
 
 
 print("–ö–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç Hani –≥–æ—Ç–æ–≤ –∫ –¥–∏–∞–ª–æ–≥—É. –ù–∞–ø–∏—à–∏—Ç–µ –≤–æ–ø—Ä–æ—Å –∏–ª–∏ '–≤—ã—Ö–æ–¥':")
 logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")
 
 current_selection = None
 last_product_query = None
 user_address = None
 awaiting_delivery_choice = False
 awaiting_address = False
+available_pickup_stores = []
 
 clarifying_phrases = [
     '–µ—Å—Ç—å –≤ –Ω–∞–ª–∏—á–∏–∏', '–µ—Å—Ç—å?', '–º–æ–∂–Ω–æ –∑–∞–±—Ä–∞—Ç—å?', '–¥–æ—Å—Ç—É–ø–µ–Ω?', '—Å–∞–º–æ–≤—ã–≤–æ–∑',
     '–≥–¥–µ –∑–∞–±—Ä–∞—Ç—å', '–∞ –µ—Å—Ç—å', '–µ—Å—Ç—å –ª–∏ –≤ –Ω–∞–ª–∏—á–∏–∏', '–Ω–∞–ª–∏—á–∏–µ?', '–≥–¥–µ –≤–∑—è—Ç—å',
     '–∑–∞–±—Ä–∞—Ç—å', '–Ω–∞ —Ç–æ—á–∫–µ', '–Ω–∞ –∫–∞–∫–æ–π —Ç–æ—á–∫–µ', '–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è —Å–∞–º–æ–≤—ã–≤–æ–∑–∞', '—Ç–æ—á–∫–∞',
     '–¥–æ—Å—Ç–∞–≤–∫–∞', '—Å –¥–æ—Å—Ç–∞–≤–∫–æ–π'
 ]
 
 while True:
     q = input("–í—ã: ").strip()
     logger.info(f"–ü–æ–ª—É—á–µ–Ω –≤–æ–ø—Ä–æ—Å: '{q}'")
 
     if awaiting_address:
         user_address = q
         total = summarize_order()
-        respond_with_delivery_info(user_address, total)
+        respond_with_delivery_info(user_address, total, available_pickup_stores)
         awaiting_address = False
         continue
 
     if awaiting_quantity:
         if q.isdigit():
             qty = int(q)
             order.append({"name": pending_product["name"], "price": pending_product["price"], "quantity": qty})
             print(f"–ë–æ—Ç: –î–æ–±–∞–≤–ª–µ–Ω–æ {pending_product['name']} x{qty} –≤ –∑–∞–∫–∞–∑.")
             pending_product = None
             awaiting_quantity = False
             print("–ë–æ—Ç: –ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë —Ç–æ–≤–∞—Ä—ã, –Ω–∞–ø–∏—à–∏—Ç–µ –∏—Ö –Ω–∞–∑–≤–∞–Ω–∏–µ. –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–ø–∏—à–∏—Ç–µ '–æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑'.")
             awaiting_finalize = True
         else:
             print("–ë–æ—Ç: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–∏—Ñ—Ä–æ–π.")
         continue
 
     if awaiting_finalize:
         if q.lower() in ["–æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑", "–æ—Ñ–æ—Ä–º–∏—Ç—å", "–∑–∞–≤–µ—Ä—à–∏—Ç—å", "–∫–æ–Ω–µ—Ü", "–Ω–µ—Ç"]:
             summarize_order()
             print("–ë–æ—Ç: –£–∫–∞–∂–∏—Ç–µ '—Å–∞–º–æ–≤—ã–≤–æ–∑' –∏–ª–∏ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ –¥–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è.")
             awaiting_finalize = False
             awaiting_delivery_choice = True
             continue
         else:
             awaiting_finalize = False
 
     if awaiting_delivery_choice:
         if "—Å–∞–º–æ–≤—ã–≤–æ–∑" in q.lower() or "–∑–∞–±—Ä–∞—Ç—å" in q.lower():
             summarize_order()
             print(
                 "–ë–æ—Ç: –£–∫–∞–∂–∏—Ç–µ –≥–æ—Ä–æ–¥ –∏–ª–∏ –∞–¥—Ä–µ—Å, —á—Ç–æ–±—ã –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É —Å–∞–º–æ–≤—ã–≤–æ–∑–∞."
             )
             awaiting_delivery_choice = False
             awaiting_address = True
             continue
         else:
             user_address = q
             total = summarize_order()
-            respond_with_delivery_info(user_address, total)
+            respond_with_delivery_info(user_address, total, available_pickup_stores)
             awaiting_delivery_choice = False
             continue
 
 
     # --- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏, –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É –ø–æ –∞–¥—Ä–µ—Å—É –∏–ª–∏ —Ä–∞–π–æ–Ω—É ---
     if any(word in q.lower() for word in ["–≥–æ—Ä–æ–¥", "–∞–¥—Ä–µ—Å", "–Ω–∞—Ö–æ–∂—É—Å—å", "—è –∏–∑", "—Ä–∞–π–æ–Ω", "–¥–æ—Å—Ç–∞–≤–∫–∞"]):
         user_address = q
         total = summarize_order()
-        respond_with_delivery_info(user_address, total)
+        respond_with_delivery_info(user_address, total, available_pickup_stores)
         continue
 
     # --- –¢–æ–≤–∞—Ä–Ω—ã–π –≤—ã–±–æ—Ä –∏ –æ—Å—Ç–∞–ª—å–Ω–æ–µ ---
     if q.lower() in ["–≤—ã—Ö–æ–¥", "exit", "quit"]:
         logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –ø–æ –∫–æ–º–∞–Ω–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
         print("–î–æ —Å–≤–∏–¥–∞–Ω–∏—è!")
         break
 
     if current_selection and q.isdigit():
         choice = int(q)
         if 1 <= choice <= len(current_selection):
             selected_product = current_selection[choice-1]
             product_row = products_df[products_df["–ù–∞–∑–≤–∞–Ω–∏–µ"] == selected_product].iloc[0]
             meta_href = product_row["Meta Href"]
             logger.info(f"–í—ã–±—Ä–∞–Ω —Ç–æ–≤–∞—Ä: Meta Href={meta_href}, –Ω–∞–∑–≤–∞–Ω–∏–µ='{product_row['–ù–∞–∑–≤–∞–Ω–∏–µ']}'")
-            stock_info = get_product_stock(meta_href, MOYSKLAD_API_KEY)
+            stock_info, available_stock = get_product_stock(meta_href, MOYSKLAD_API_KEY)
             print("–ë–æ—Ç:", stock_info)
-            if "–Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏" not in stock_info.lower():
+            if available_stock:
+                available_pickup_stores = list(available_stock.keys())
                 price = get_product_price(product_row["–ù–∞–∑–≤–∞–Ω–∏–µ"])
                 pending_product = {"name": product_row["–ù–∞–∑–≤–∞–Ω–∏–µ"], "price": price}
                 print("–ë–æ—Ç: –°–∫–æ–ª—å–∫–æ —à—Ç—É–∫ –¥–æ–±–∞–≤–∏—Ç—å –≤ –∑–∞–∫–∞–∑?")
                 awaiting_quantity = True
+            else:
+                available_pickup_stores = []
             last_product_query = selected_product.lower()
             current_selection = None
             continue
         else:
             print("–ë–æ—Ç: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.")
             continue
 
     if current_selection:
         print("–ë–æ—Ç: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–æ–≤–∞—Ä–∞ –∏–ª–∏ –∑–∞–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å.")
         continue
 
     if detect_stock_question(q):
         query_words = extract_product_name(q).split()
         if (
             (len(query_words) <= 2 and last_product_query)
             or any(phrase in q.lower() for phrase in clarifying_phrases)
         ):
             product_query = last_product_query if last_product_query else extract_product_name(q)
         else:
             product_query = extract_product_name(q)
             last_product_query = product_query
 
         logger.info(f"–ò–∑–≤–ª–µ—á–µ–Ω –∑–∞–ø—Ä–æ—Å —Ç–æ–≤–∞—Ä–∞: '{product_query}'")
         if not product_query:
             print("–ë–æ—Ç: –°–Ω–∞—á–∞–ª–∞ —É—Ç–æ—á–Ω–∏—Ç–µ, –∫–∞–∫–æ–π —Ç–æ–≤–∞—Ä –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç.")
             continue
 
         similar_products = find_similar_products(product_query, all_product_names)
         if not similar_products:
             print("–ë–æ—Ç: –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∞—Å—Å–æ—Ä—Ç–∏–º–µ–Ω—Ç–µ.")
             continue
 
         if len(similar_products) > 1:
             original_names = []
             for name in similar_products:
                 original_name = products_df[products_df["–ù–∞–∑–≤–∞–Ω–∏–µ"].str.lower() == name].iloc[0]["–ù–∞–∑–≤–∞–Ω–∏–µ"]
                 original_names.append(original_name)
 
             print("–ë–æ—Ç: –£—Ç–æ—á–Ω–∏—Ç–µ, –∫–∞–∫–æ–π –∏–º–µ–Ω–Ω–æ —Ç–æ–≤–∞—Ä –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç:")
             for i, name in enumerate(original_names, 1):
                 print(f"{i}. {name}")
             print("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–æ–≤–∞—Ä–∞.")
             current_selection = original_names
             continue
 
         product_name = similar_products[0]
         product_row = products_df[products_df["–ù–∞–∑–≤–∞–Ω–∏–µ"].str.lower() == product_name].iloc[0]
         meta_href = product_row["Meta Href"]
         logger.info(f"–í—ã–±—Ä–∞–Ω —Ç–æ–≤–∞—Ä: Meta Href={meta_href}, –Ω–∞–∑–≤–∞–Ω–∏–µ='{product_row['–ù–∞–∑–≤–∞–Ω–∏–µ']}'")
-        stock_info = get_product_stock(meta_href, MOYSKLAD_API_KEY)
+        stock_info, available_stock = get_product_stock(meta_href, MOYSKLAD_API_KEY)
         print("–ë–æ—Ç:", stock_info)
-        if "–Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏" not in stock_info.lower():
+        if available_stock:
+            available_pickup_stores = list(available_stock.keys())
             price = get_product_price(product_row["–ù–∞–∑–≤–∞–Ω–∏–µ"])
             pending_product = {"name": product_row["–ù–∞–∑–≤–∞–Ω–∏–µ"], "price": price}
             print("–ë–æ—Ç: –°–∫–æ–ª—å–∫–æ —à—Ç—É–∫ –¥–æ–±–∞–≤–∏—Ç—å –≤ –∑–∞–∫–∞–∑?")
             awaiting_quantity = True
+        else:
+            available_pickup_stores = []
         last_product_query = product_name
 
     else:
         logger.info("–í–æ–ø—Ä–æ—Å –Ω–µ –ø—Ä–æ –Ω–∞–ª–∏—á–∏–µ - –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ YandexGPT")
         result = qa.run(q)
         print("–ë–æ—Ç:", result)
 
EOF
)